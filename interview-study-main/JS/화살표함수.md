# 화살표함수

## 동현

### 일반 함수와 화살표 함수의 차이

표현법 이외에도 크게 3가지 차이점이 존재합니다.

우선, `this binding`에 대한 부분입니다. 일반 함수의 경우 this는 함수의 호출방식에 따라 다른 값이 바인딩됩니다. (this 바인딩과 연결될 수 있음) 하지만, 화살표 함수는 무조건 상위 스코프의 this를 참조하게 됩니다. 또한, apply/call/bind와 같은 간접 호출 방식으로 인해 this가 변하지도 않습니다.  
(참고: this 바인딩 뿐 아니라, super, arguments, new.target 등의 바인딩 역시 같은 플로우)

다음으로는 `객체의 생성자로 사용할 수 없다`는 점입니다. 화살표 함수는 prototype 프로퍼티를 가지고 있지 않으며 constructor가 존재하지 않습니다.

또한 `코드상 선언부 이전에 호출이 불가능`합니다. const, let 키워드를 통해 화살표 함수를 선언했을 경우에는, 할당문 이전에 사용시 ReferenceError가 뜨게 됩니다. var 키워드를 통해 선언했을 경우에는 할당 전에는 undefined 값을 가지기 때문에 호출할 수 없습니다.

### 화살표 함수 사용에 불리한 조건

1. `객체의 메서드`를 정의하는 경우입니다. 화살표 함수로 이루어진 메서드 내부에서 this를 사용하면 이를 호출한 객체가 아닌, 대부분 전역 객체를 가리키게 됩니다.
2. `프로토타입 메서드`를 정의하는 경우입니다. 이 역시 인스턴스를 가리키는게 아닌 전역 객체를 가리키게 됩니다. (일반 함수를 사용해서 호출하는 객체를 this로 바인딩 해야한다.)
3. `생성자 함수`로 사용할 경우입니다. 생성자 함수는 prototype 프로퍼티를 가져야 하지만, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않습니다.
4. `addEventListener 함수의 콜백 함수`를 정의하는 경우입니다. 콜백함수를 일반 함수로 사용할 경우, this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킵니다. 하지만, 화살표 함수를 이용하면 this는 전역 객체를 가리키게 됩니다.
## 1차에서 대답 못했던 것들 다시 준비

- http와 https의 차이? [테코톡](https://www.youtube.com/watch?v=wPdH7lJ8jf0&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=20)
    - 우선 http는 다른 시스템 사이에서 통신을 하는데 사용되는 기본적인 프로토콜입니다.
    - http는 전송하는 데이터가 암호화되지 않는 문제가 있어 공격에 취약합니다.
    - https는 http에 SSL을 사용한 프로토콜입니다.
    - SSL을 사용해서 중간에 주고받는 데이터들을 암호화하여 데이터가 도난당하는 것을 막습니다.

    - 이 보안의 이유로 https를 사용해야하지만, 다른 이유로는 검색 엔진 최적화, 즉 SEO를 위한 이유도 있습니다.
    - 저희는 검색 엔진으로서 구글을 많이 사용하는데요, 구글링을 한다고 많이들 부릅니다.
    - 구글은 https를 사용한 사이트에 가산점을 주어, 사용자가 검색했을 때 저희가 만든 웹사이트가 더 잘 노출될 수 있게 해줍니다.

- SSL 인증 과정?
    - Secure Sockets Layer의 약자
    - 공개키/개인키 방식, 대칭키 방식을 혼합해서 사용한다

    - A가 B에게 접속 요청을 보냅니다.
    - 그러면 B는 A에게 자신의 공개키를 보냅니다.
    - A는 그 B의 공개키로 자신의 대칭키를 암호화하여 B에게 보냅니다.
    - B는 A의 암호화된 대칭키를 자신의 개인키로 복호하하여 A의 대칭키를 알아냅니다.
    - 이제 그 키를 통해 A와 B는 안전한 통신이 가능해집니다.

    - 이 과정은 A와 B가 데이터를 암호화해서 주고받아야 하는데, 데이터를 해석할 대칭키를 외부에서 알지 못하도록 하는 과정입니다.

- 로드밸런서에 대해서 알고계신가요?
    - 네 리버스프록시에서 사용되는 방법입니다
    - 포워드 프록시부터 말씀드리겠습니다
    - 포워드 프록시는 클라이언트와 인터넷 사이에 존재하는 프록시서버구요
    - 리버스 프록시는 반대로 프록시서버가 인터넷과 서버사이에 존재합니다
    - 여기서 클라이언트가 여러 요청을 보냈을때 프록시서버에 여러 처리해야하는 작업이 쌓일텐데 이때 로드밸런서가 여러 서버들에게 그 처리해야되는 일들을 나눠주는 역할을 합니다. 부하를 분산시켜줍니다.

- 아하 그렇군요 그부분은 약간 소프트웨어적인 느낌인것같은데 하드웨어적인 부분에서 설명가능할까요
    - L4, L7를 알고있습니다.
    - L4 Load Balancer는 Transport Layer에서, IP와 Port레벨에서 로드밸런싱을 합니다.
    - 어떤 URL로 접근시 서버 A와 서버 B로 로드밸런싱을 합니다.
    - 80포트로 접근을 하게 되는데, 서버 A와 서버 B로 요청을 고르게 나눠줍니다.

    - L7 Load Balancer는 Application Layer에서 로드밸런싱을 하는데요.
    - 어떤 URL로 접근시, 뒤에 무엇을 붙이느냐에 따라서, 혹은 query param에 대해서, 그 어플리케이션 요청하는 방법에 따라서 어떤 서버로 로드밸런싱을 할지 결정하는게 L7입니다.
    - 예로 /category, /search를 담당 서버들로 로드밸런싱을 해줍니다.

- (*나왔던건 아님*) 브라우저 렌더링 방식
    - 렌더 엔진이 HTML을 파싱하여 DOM 노드로 이루어진 트리 생성
    - CSS 파일과 inline 스타일을 파싱하여 DOM + CSSOM = 렌더 트리를 생성
    - 각 노드들의 스크린에서의 좌표에 따라 위치를 결정하는 Layout(reflow) 과정
    - 실제 화면에 그리는 Paint(repaint) 과정

    - 어떤 인터랙션에 의해 DOM에 변화가 발생하면 렌더트리가 그때마다 재생성되는 현상
    - 변화가 발생하면 모든 요소의 스타일을 다시 계산하고 reflow, repaint 과정이 반복된다.
    - 최근 SPA가 많이 사용되기 시작하면서 DOM tree를 즉각적으로 변경할 일이 많이 생긴다.
    - 전체 페이지를 서버에서 매번 보내주는 것이 아니라 브라우저 단에서 JS가 관리하기 때문에 DOM 조작을 효율적으로 할 수 있게끔 최적화가 필요해졌다.
    - 그래서 virtual DOM이 등장한다.
    - virtual DOM은 기존 DOM의 친구이자, 복사본이라고 할 수 있다.

- 리액트에서 렌더링되는 방법, virtual DOM [정리할 사이트](https://www.youtube.com/watch?v=PN_WmsgbQCo)
    - 데이터가 변경되면 전체 UI는 virtual DOM에 렌더링됩니다.
    - 이전 virtual DOM에 있던 내용과, 업데이트 후의 내용과 비교하여 바뀐 부분만 실제 DOM에 적용시킵니다.
    - virtual DOM에 변경사항이 적용되면 원본 DOM에 필요한 변화만 반영되어 전체 real DOM을 바꾸지 않고도 필요한 UI의 업데이트를 적용시킬 수 있습니다.
    - virtual DOM은 html 객체에 기반한 자바스크립트 객체로 표현할 수 있습니다.
    - 요소가 30개가 바뀌었다고 레이아웃을 30개씩 새로 만드는것이 아니라 모든 변화를 하나로 묶어서 한번만 실행시킵니다.
    - 공식문서에서의 virtual DOM은 "UI의 가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM을 동기화" 하는 프로그래밍 개념이다라고 설명합니다.

    - 모든 React DOM object는 그에 대응하는 virtual DOM object가 있습니다.
    - virtual DOM object는 그 DOM object 하나하나에 매핑됩니다.
    - 데이터가 업데이트되면 바뀐 데이터를 바탕으로 React.createElement()를 통해 JSX element를 렌더링합니다.
    - 이때 모든 각각의 virtual DOM object가 빠르게 업데이트됩니다.
    - Diffing 알고리즘을 통해 이전 virtual DOM 스냅샷과 업데이트된 virtual DOM의 변경사항을 알아차린 후 변경부분만 적용시킵니다.
    - Diffing 알고리즘은 element의 속성이 바뀌었다면 속성값만 업데이트, 태그 또는 컴포넌트가 변경된 경우 해당 노드를 포함한 하위 모든 노드를 unmount하고 새로운 virtual DOM으로 대체합니다.
    - 이런 변경이나 업데이트가 모두 마무리된 이후에 딱 한번만 실제 DOM에 이 결과를 업데이트합니다.

- 협업할때 버전 맞추는 방법, package.json 들어보셨나요? 버전 맞추려면 어떻게해야되나요 package.json, package-lock.json 설명좀요 [번들러 아래질문 포함](https://www.youtube.com/watch?v=9b89f21Sizs&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=46)
    - package.json
        - 의존성 선언에는 version range가 사용됩니다.
        - 특정 버전이 아니라, 버전의 범위를 의미하기때문에 라이브러리의 버전이 업데이트되면 다른 팀원과 협업시 다른 버전이 설치될 수 있어 프로젝트가 실행되지 않는 오류가 발생할 수 있습니다.

    - package-lock.json
        - 의존성 트리에 대한 정보를 모두 가지고 있습니다.
        - 저장소에 포함시켜 커밋해야합니다.

- Webpack, 번들링 왜함?
    - 모듈 번들러는 말그대로 여러 모듈을 모아 번들링함으로써 js파일, css파일, 이미지파일 등을 따로따로 네트워크 통신을 통해 가져오는 문제를 해결합니다.
    - 웹팩에서는 모든 파일을 모듈로 봅니다.
    - js뿐만 아니라 css파일, 이미지, 폰트 파일 까지도요.
    - 서로 의존성을 가진 여러 모듈을 돌며 여러개의 js파일을 하나의 js파일로 여러 sass파일을 하나의 css파일로 묶습니다.
    - 웹팩을 사용할 때에는 세가지 필수 설정이 필요합니다.
    - mode는 개발, 프로덕션 같은 모드를 나타내고 entry는 모듈이 시작되는 부분을 나타냅니다.
    - 일반적으로 entry는 index.js가 됩니다.
    - output은 번들링된 파일들을 저장할 위치입니다.
    - 일반적으로 dist나 build라는 이름의 폴더를 사용합니다.

    - loader는 웹팩이 js파일이 아닌 웹 자원(html, css, 이미지, 폰트 등)을 변환할 수 있도록 만들어주는 도구입니다.
    - 자주 사용되는 것은 js에서 css파일을 모듈로서 가져올 수 있게 하는 css-loader, js로 들어간 css를 html에 넣어 브라우저 렌더링 시 적용될 수 있게 해주는 style-loader, 이미지를 모듈로 사용할 수 있게 해주는 file-loader등이 있습니다.
    
    - plugin은 번들된 결과물의 형태를 바꾸는 일을 합니다.
    - 난독화나 특정 문자열 치환 등의 처리를 할 수 있습니다.
    - 예시로는 개발용 api와 배포용 api 주소를 서로 다르게 설정하는 것과 같은 환경 의존적인 정보를 관리하는데 사용하는 DefinePlugin이 있습니다.
    
    - 바벨은 *크로스 브라우징* 문제를 해결합니다.
    - *잘못 말한 것 같음 1차때*
        - 웹 접근성과 크로스 브라우징은 다르다. 다시 말하게 되면 실수하지 않기

- (*나왔던건 아님*) REST API?

- 채팅을 구현할때 socket io로 구현하셨던데 그 polling 방식같은거 아세요?
    - polling
        - 전송할 데이터의 유무에 관계없이 주기적으로 요청을 수행하는 방법
        - 클라이언트는 지정된 시간 간격에 맞춰 서버에 지속적인 요청을 보낸다.
        - 서버는 각 요청마다 가용 데이터나 데이터가 없는 경우 빈 데이터를 보내거나 실패와 같은 적절한 응답을 한다.

        - 데이터의 유무에 관계없이 요청하여 불필요한 네트워크 비용이 발생한다.
        - 클라이언트와 서버 자원을 많이 낭비한다.
        - 요청의 간격이 길면 실시간성이 떨어진다.
        - 반대로 간격이 짧으면 많은 자원을 소비한다.
        - 서버 이벤트가 일정한 주기로 발생하면 효율적이다.

    - long polling
        - 서버 이벤트가 발생할때까지 응답을 미루는 방법이다.
        - 폴링과 다르게 클라이언트의 요청에 대해 서버가 전송할 데이터가 있거나 타임아웃 될 때까지 연결을 끊지 않고 지속한다.
        - 서버로부터 응답을 받는 즉시 롱 폴링 요청을 다시 수행한다.

        - 폴링과 다르게 불필요한 네트워크 비용이 덜 발생한다.
        - 서버 이벤트가 발생하는 즉시 응답을 하기 때문에 실시간성이 높다.
        - 반대로 서버 이벤트가 빈번하게 발생하면 폴링보다 더 많은 요청을 수행한다.

    - Websocket
        - http가 아닌 웹소켓을 사용하여 실시간 양방향 통신을 지원하는 방법이다.
        - http를 통해 웹소켓 프로토콜로 전환하는 handshake과정이 필요하다.
        - 이후 웹소켓을 통해 통신이 이루어진다.

        - http를 사용하지 않아 전체 메시지 크기가 줄어든다.
        - 클라이언트와 서버의 자원을 최소화할 수 있다.
        - 양방향으로 빠른 요청과 응답이 가능하다.

- 그럼 socket io 안쓰고 채팅을 어떻게 구현하실것같으세요? 요청 응답 같은거 관련해서 설명해주세요 [정리할 사이트](https://www.youtube.com/watch?v=0jV7xOUcKog&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=82)
 [정리할 사이트2](https://www.youtube.com/watch?v=xz7e-GL2g6g&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=133)
    - http는 단방향성, 비연결성, 무상태성
    - 소켓통신은 연결이 쭉 유지되어서 채팅에서 많이 이용된다. 이런거 관련해서 찾아보기

- Java와 JavaScript의 차이?
    - 1차때 이 질문을 받았을때 의도를 파악하지 못했던것같아서 아쉬웠습니다.
    - 이름이 비슷해서 Java가 있고, JavaScript가 있는데 그래서 JavaScript가 왜 JavaScript냐 이런 차이에서 그 기원같은 것들을 질문주신줄 알았는데 복기해보니 정적언어, 동적언어 관해서 질문을 주셨었구나 생각했습니다.
    - 우선 Java는 정적언어이고, JavaScript는 동적언어에 해당됩니다.
    - 정적언어란 컴파일 시 변수의 타입을 체크하는 언어이고, 동적언어란 런타임에 변수의 값에 따라 타입이 결정되는 언어입니다.
    - 예로 정적언어에서는 String, int 같은 문자열, 정수 자료형으로 변수를 선언해야하지만 JavaScript 같은 동적언어에서는 var, let, const로 변수를 선언합니다.
    - 동적언어의 경우 개발자가 타입을 고려하지 않으며 빠르게 개발을 할 수 있다는 장점이 있지만 이로 인한 사소한 실수를 발견하기 힘들고, 정적언어는 이와 반대되는 장단점을 가지고 있습니다.

- C++ 질문

- 혹시 vector와 list의 차이는 뭘까요?
    - 어떤 인덱스의 데이터에 접근하기 위한 시간복잡도가 다릅니다.
    - 우선 벡터의 경우 O(1)의 시간이 들고, 리스트에는 포인터로 연결되어있기 때문에 어떤 값을 찾기 위해서는 O(n)의 시간이 걸립니다.
    - 하지만 어떤 데이터를 자료구조 중간에 삽입하거나, 삭제하기 위해서는 벡터의 경우 넣고 밀고, 삭제하고 당기고 해야 하기때문에 O(n), 리스트의 경우 데이터를 만들고 포인터를 잇고, 삭제하고 포인터를 또 다시 이어주기만 하면 되기때문에 O(1)의 시간이 걸립니다.
    - 저번 면접에서 벡터만 써봤다고 해서 대답을 못드렸었는데요, 일반화하긴 힘들지만 특수한 경우를 제외하고는 99% 벡터만 사용된다고 합니다.
    - 이유는 find로 자료구조 내 어떤 데이터를 찾아야하는 경우, 벡터와 리스트 모두 전체 데이터를 훑어 찾아야하기 때문에 O(n)의 시간이 걸리지만 컴퓨터의 구조 때문에 벡터의 find가 더 빠르다고 합니다.
    - 벡터는 연속적인 구조를 가지고, 리스트는 포인터로 데이터들이 연결된 구조를 가집니다.
    - 실제 메모리 구조는 격자형태로 되어있고, 두 자료구조가 실제메모리에 저장되어 데이터를 훑을때에는 캐시가됩니다.
    - 벡터는 연속적으로 되어있기때문에 캐싱되어 다시 find할때 시간이 덜 걸리지만 리스트의 경우 연속적이지 않고 이곳저곳 저장되어 포인터로 연결되어있어 다시 find를 할때 cache miss가 일어나 벡터보다 리스트가 실제 find시간이 오래걸립니다.
    - 추가로 리스트의 경우 포인터를 저장하는 메모리가 추가적으로 발생하기때문에 특수한 아주 적은 경우를 제외하고는 벡터를 더 많이 사용합니다.

- 알고리즘문제를 좋아하신다하셨는데 알고리즘을 다 C++로 푸셨더라구요. C++과 js의 클래스 차이는?
    - C++은 클래스 기반 언어, JavaScript는 프로토타입 기반의 언어입니다.
    - JS에는 별도의 클래스 문법이 없었는데, ES6 이후 class 문법이 추가됐습니다.
    - 하지만 프로토타입에서 클래스타입으로 언어 자체가 바뀐 것이 아니라 문법적으로 지원하기만 하는 것입니다.
    - 차이점중 하나로 알고있는 것은 다중상속 가능 여부의 차이입니다.
    - C++은 다중상속이 가능하지만 JS같은 프로토타입 기반의 언어로는 원칙적으로 다중상속이 불가능하다고 알려져있습니다.
    - JS 객체의 [[Prototype]]이 하나만 가리켜야하기때문이라 가능하지 않은것으로 알려져있고 편법으로는 가능하다고하지만 때문에 JS를 객체지향언어가 아니기 때문에 비판하는 사람도 있습니다.

    ```    
    - 오버라이딩(Overriding)
        - 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다.
    - 오버로딩(Overloading)
        - 매개변수의 타입 또는 갯수가 다른, 같은 이름의 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식이다.
        - 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다.
    - super 키워드
        - super 키워드는 부모 클래스를 참조(Reference)할 때 또는 부모 클래스의 constructor를 호출할 때 사용한다.
    
    ## 클래스 기반 언어
        - 클래스 기반 언어(Java, C++, C#, Python, PHP, Ruby, Object-C)는 클래스로 객체의 자료구조와 기능을 정의하고 생성자를 통해 인스턴스를 생성한다.

        - 클래스란 같은 종류의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user define data type)이라고 할 수 있다. 결국 클래스는 객체 생성에 사용되는 패턴 혹은 청사진(blueprint)일 뿐이며 new 연산자를 통한 인스턴스화 과정이 필요하다.

        - 모든 인스턴스는 오직 클래스에서 정의된 범위 내에서만 작동하며 런타임에 그 구조를 변경할 수 없다. 이러한 특성은 정확성, 안정성, 예측성 측면에서 클래스 기반 언어가 프로토타입 기반 언어보다 좀 더 나은 결과를 보장한다.

        - 아래의 예제는 Java로 구현된 클래스이다. Java는 class 키워드를 제공하고 이것으로 클래스를 정의한다. 생성자는 클래스명과 동일하며 메소드로 구현된다.
    
    ## 프로토타입 기반 언어
        - 자바스크립트는 멀티-패러다임 언어로 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 언어다. 비록 다른 객체지향 언어들과의 차이점에 대한 논쟁들이 있긴 하지만, 자바스크립트는 강력한 객체지향 프로그래밍 능력들을 지니고 있다. 간혹 클래스가 없어서 객체지향이 아니라고 생각하는 사람들도 있으나 프로토타입 기반의 객체지향 언어다.

        - 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.
    ```

- C++ 객체지향에서의 특징
    - 상속
        - 다른 클래스의 멤버를 인계받아서 새로운 클래스를 정의하는 것
        - 그대로 물려받아 사용하기 때문에 재사용에서 큰 효율이 있습니다.
        - 인계받은 것을 바탕으로 그 인스턴스만의 새로운 속성이나 메소드를 정의해서 사용가능합니다.
    - 캡슐화
        - 중요한 데이터를 보호하는 것입니다.
        - 연관 있는 변수와 함수를 클래스로 묶는 작업을 말합니다.
        - 은닉화의 특성이 있는데요, 외부에서 특정 속성이나 메소드를 사용할 수 없게 하는 것입니다.
        - 언더바를 붙여서 약간 암묵적으로 그 언더바가 붙은 속성이나 메소드는 사용하지 말아라 라고 사용하기도 합니다.
    - 다형성 
        - 서로 다른 유형의 객체가 동일한 메시지에 대해 다르게 반응하는 것
        - 동일한 메시지를 처리한다 == 같은 역할을 수행한다
        - 다르게 반응한다 == 메시지 처리 방법은 자율적이다

- (*나왔던건 아님*) C++ 가상함수? virtual?
    - 가상 함수는 실행시간(런타임)에 그 값이 결정됩니다.
    - 일반 함수는 컴파일 시에 결정됩니다.
    - 몸체 클래스가 있고, 그를 상속한 파생 클래스가 있습니다.
    - 몸체 포인터를 만들고 파생 클래스를 가리키게 합니다.
    - 이제 여기서 같은 이름의 메소드를 재정의하여 실행하게하면 이제 그 메소드가 virtual로 선언되었는지, 일반함수로 선언되었는지에 따라 실행되는 것이 다릅니다.
    - virtual로 선언되었다면 런타임에 실행할 함수를 결정하고, 일반함수로 선언되었다면 컴파일시에 실행함수를 결정하여 출력이됩니다.
    - 파생 클래스가 재정의할 가능성이 있는 함수는 모두 가상 함수로 선언하는 편이 좋습니다. 헷갈리니까요.

    - 예시)
    - 캐릭터라는 베이스 클래스가 있고, 그로부터 파생된 전사, 궁수, 법사라는 파생 클래스가 있다고하겠습니다.
    - 베이스 클래스에는 공격에 대한 메소드가 virtual로 정의되어있습니다.
    - 이유는 전사, 궁수, 법사가 완전히 같은 공격을 하는게 아니라 조금씩 변형된 공격을 하기 때문입니다. 반드시 재정의를 해줘야 합니다.
    - 그렇게 Attack이라는 메소드를 파생 클래스에서 재정의해서 사용해야할 때 이런 방법을 사용합니다. 편한 장점이죠.

    - 하지만 이 가상함수에 단점을 꼽자면 그래도 일단 존재는 해야되는 부분이다보니까 메모리를 일반함수보다는 더 잡아먹는 단점과, 일반적인 함수는 호출될때 바로 접근하는데에 비해서 가상함수를 거쳐서 호출되기 때문에 상대적으로 호출 시간이 좀더 길다는 단점이 있습니다.

- 알고리즘 질문할게요 그럼 탐색 관련해서 최근에 공부했던거 설명가능하신지?
    - 아 그럼 바로 생각나는게 최단 경로 탐색 알고리즘인데 설명드려도 될까요? -> ㅇㅋㅇㅋ
    - 대표적으로 다익스트라와 플로이드 와샬이 있는데 설명드리겠습니다
    - 여기서부터는 내 머리속에 들어있는 코드대로 설명을 드렸음
    - 진짜 래퍼처럼 코드한줄한줄 설명 읊었는데 심취해서 설명하다가 이게 내 머릿속 코드임을 설명중간에 깨닫고 헉 제가 지금 코드설명을 하고있네요 이게 아닌데
    - 웃으시면서 네네 그러신것같아요 여기까지 듣도록 하겠습니다 하고 넘어감

- DB는 뭐써보셨나요?
    - MySQL요

- 클러스터드 인덱스, 넌클러스터드 인덱스에 대해서 설명해주세요 [정리할 사이트](https://www.youtube.com/watch?v=js4y5VDknfA)
    - 우선 인덱스는 DB에서의 검색 속도 향상을 위한 자료구조입니다.
    - 클러스터드 인덱스는 군집화된 인덱스인데요, 뭐가 군집되어있냐 하면 데이터와 인덱스가 군집되어있습니다.
    - 인덱스와 데이터가 연결되어있다 이런식으로 이해하면 될것같고 반대로 넌클러스터드 인덱스는 그렇게 되어 있지 않고 인덱스에 그 데이터를 가리키는 주소가 들어있습니다.
    - 이 특징 자체로만 생각을 해보자면 넌클러스터드 인덱스가 클러스터드 인덱스보다 데이터를 조회하기 위한 시간이 더 걸립니다.
    - 이유는 인덱스를 사용해서 데이터를 찾으려면 클러스터드는 인덱스에서 바로 데이터를 뽑아내는데 넌클러스터드는 주소를 이용해서 한번 더 이동해서 데이터를 찾아야하기 때문이죠.
    - 그럼 이제 이걸 어떻게 사용해야하는지 공부해봤는데요.
    - 우선 사람 테이블에 성별, 이메일, 이름 컬럼이 있다고 해보겠습니다.
    - pk를 걸면 자동으로 클러스터드 인덱스가 생성되기 때문에 이를 바탕으로 설명드리겠습니다.
    - 인덱스는 중복이 덜 발생하는 컬럼에 걸어야합니다.
    - 중복이 자주 일어나는 컬럼에 걸면 결국 테이블을 풀스캔해서 찾아야하니 안건것과 별로 다를게 없기 때문인데요,
    - 그럼 이메일에 pk를 건다고 해보겠습니다.
    - 이메일은 거의 고유한 값들이 들어가고, 중복이 거의 일어나지 않기때문에 괜찮을것같아요.
    - 하지만 이메일에 걸면 성능 저하가 발생합니다.
    - 이유는 pk를 걸면 그 컬럼에 대해서 정렬이 발생하는데, 데이터 삽입이 잦다면 그만큼 정렬도 자주 일어나기때문에 조회만 하는 경우가 아니라면 성능저하가 발생합니다.
    - 결국엔 이메일에는 pk를 걸지 않고, 유니크를 준 후 id같은 컬럼을 만들어서 auto increment를 주거나 해서 id에 pk를 걸면 인덱스를 잘 사용할수가 있습니다.

    - 사실 인덱스가 만능은 아닙니다.
    - 인덱스를 타고 다시 테이블을 훑는 경우도 발생하는데, 이런경우에는 비효율적입니다.
    - 일반적으로 인덱스를 사용하고 선택된 데이터가 적을때 인덱스가 유용한데, 선택 데이터가 전체의 10% 미만인 경우 사용하는것이 좋습니다.

    ```
    - Clustered Index : 군집화된 인덱스. 뭐가? 인덱스와 데이터가 군집
        
        - 클러스터드 인덱스 즉 PK가 이메일로 됐기 때문에 성능 이슈가 발생할 수 있다고 지적
        - 이메일에 고유한 값을 매겨야하니 Id값을 주셨을텐데 아마 이거는 유니크 키를 주시고 PK는, 클러스터드 인덱스는 다른 값으로 주는게 유리하겠죠
            - 인덱스는 중복이 덜 일어나는 컬럼에 걸어야한다, pk를 걸면 자동으로 클러스터드 인덱스가 생긴다, 즉 이메일에 pk를 건다?? 는 안좋을것같다, 정렬이 일어나는데 이메일에 걸고 데이터 삽입이 자주 일어나면 정렬도 그만큼 자주일어나기에 안좋기때문, 
        - 인덱스를 타는지 안타는지 보려면 explain (analyze) (쿼리플랜) / 시각화로 볼수도있음
        - 클러스터링 인덱스 ( = 클러스터드 인덱스 ) : 인덱스가 아니다. 스토리지다. : 디스크에 데이터를 저장하는 자료구조 일종
        - PK, FK는 '자동'으로 인덱스가 생성됨.
            빠르게 검색을 하고 싶다 > 컬럼에 index를 생성해준다.

            인덱스를 안걸면 : DB 테이블 풀스캔해서 찾아서 느림.

            인덱스를 만들때 느린 이유 : b+ 자료구조를 새로 만들기 때문
            그 이후엔 해당 컬럼에 대한 빠른 쿼리를 실행할 수 있음.

            인덱스는 만능이 아니다
            인덱스를 타고 다시 테이블을 훑는 경우가 있음
            이런경우에는 소용이 없다

            인덱스가 유용한 경우 : 인덱스 사용 후 선택된 데이터가 적을 때

            데이터가 많으면 많아질수록 성능이 떨어진다.

            선택 데이터가 전체의 10% 미만일 경우 인덱스가 유용하다 ( 빠르다 )

            필터링되는 데이터가 원본 데이터보다 적을 때 좋다

            복합 인덱스 : '순서' 중요 / 컬럼 A, B에 대해 인덱스를 걸어줬다면
            A에대해 조회, A,B 모두 조회 할 경우 빠르다
            B를 조회하는 것에 대해서는 적용이 안됨.

            인덱스 장점 : 빨라진다
            단점 : 생성삭제가 느려진다 ( 생성삭제 할때마다 인덱스 B+트리가 변경된다. )

            인덱스 필터링되는 결과가 적을수록 좋다.
            = 해당 컬럼의 셀렉티비티가 높을수록 좋다

            복합인덱스는 정말 필요할때만 만드는게 좋다
            웬만하면 따로 만드는게 좋다
    ```

- (*나왔던건 아님*) OLTP, 트랜잭션
    - 트랜잭션이란 여러 쿼리를 하나의 작업으로 묶어주는 것을 말합니다.
    - 은행에서의 송금 과정을 예시로 들어보겠습니다.
    - A가 B에게 만원을 송금할때, 두가지 쿼리가 있을수 있겠죠.
    - A계좌에서 만원이 빠져나간다, B계좌에 만원이 들어온다. 이 두 쿼리가 있을 수 있겠습니다.
    - 그러면 이 두 과정이 한번에 처리가 되어야 하겠죠? 만약에 오류가 발생한다면 A에게서는 돈이 빠져나갔는데 B에게는 돈이 들어오지 않는 상황이 발생할 수가 있는데 이제 이런 현상이 발생하지 않기 위해서 이 두 작업을 하나로 묶어주는것이 트랜잭션입니다.
    - 트랜잭션의 특징이라고해서 ACID라고 있는데, Atomicity, Consistency, Isolation, Durability를 의미합니다.
    - 트랜잭션 안 쿼리는 동시에 모두 처리가 되어야한다는 원자성,
    - 트랜잭션 처리 결과는 일관되어야한다는 일관성,
    - 트랜잭션 여러개가 수행될경우 서로 영향을 주면 안된다는 독립성,
    - 트랜잭션 처리 후 DB에 반영되는 정보는 영구히 적용되어야한다는 영속성입니다.

    - 커밋과 롤백이라고도 있는데 커밋은 트랜잭션 처리가 잘 수행되었을 경우 반영하는것을 커밋, 중간에 오류가 발생해서 트랜잭션 처리 전으로 되돌리는 것을 롤백이라고 합니다.

    - OLTP는 온라인 트랜잭션 프로세싱을 말합니다.
    - 효율적인 업무를 처리하기 위한것이고, 트랜잭션 단위로 처리하기 때문에 소규모의 일관된 데이터 처리가 중점입니다.
    - 제한된 인덱스가 생성되었을 때 성능이 좋아집니다.

    ```
    OLTP(On-Line Transaction Processing)
    다수의 이용자가 실시간으로 데이터를 갱신하거나 조회하는 경우 트랜잭션 단위로 작업을 처리하는 방식을 말합니다.

    간단한 예시로 은행의 업무를 예로
    A라는 사람 통장의 돈 5000원을 B라는 사람에게 이체하는 방식을 살펴봅시다    

    1. A의 통장에서 5000원이 감소
    2. B의 통장에 5000원이 증가
    3. 명세표를 출력

    이렇게 동작할때 1,2,3이 하나의 단위 프로세스로 처리가 되어야한다는 것을 의미합니다.
    이러한 일련의 과정을 하나의 트랜잭션으로 묶고 
    A의 통장에서 5000원이 감소하고 B의 통장에 5000원이 증가하기 전에 오류가 발생하게 되면
    트랜잭션이 발생하기 전의 상황으로 돌아가게 되는 것입니다.

    - 효율적인 업무 처리 기반
    - 트랜잭션 단위로 처리하기 때문에 소규모의 정교하고 일관된 데이터 처리가 중점(입력, 조회, 수정, 삭제)
    - 제한된 Index가 생생되었을 때 최고의 성능을 발휘 (데이터가 변화할 때 Index가 같이 수정되기 때문에 트랜잭션 LOCK에 의해 성능이 저하)
    ```

- (*나왔던건 아님*) Mutex, Semaphore, DeadLock [테코톡](https://www.youtube.com/watch?v=oazGbhBCOfU)
    - 교착상태 
        - 두 가지 이상의 작업이 서로 상대방의 작업이 끝나기를 한없이 기다리는 상태입니다.
        - 종이와 연필이 한 쌍, 그리고 두 사람이 있다고 하겠습니다.
        - 한 사람은 필기를 위해 연필을 가져가고, 다른 사람을 종이를 가져갔습니다.
        - 근데 필기를 하려면 종이와 연필이 동시에 필요하기에 서로는 각각의 자원을 가져가기 위해 대기하고 있습니다.
        - 이렇게 서로가 서로의 작업이 끝나기만을 기다리지만 끝나지 않는 상태에 있는 상황이 데드락, 교착상태입니다.
        - 여기서 연필과 종이가 공유자원이고, 이런 공유자원이 속해있어 교착상태가 발생할 수 있는 영역을 임계영역이라고 합니다.
        - 교착상태가 발생하려면 네가지 조건을 만족해야합니다.
            - 상호배제
            - 점유대기
            - 비선점
            - 순환 대기
        - 여기서 상호 배제에 관련된 것이 뮤텍스라는 것입니다.
        - 상호 배제란 Mutual Exclusion으로 말할수 있는데, 뮤텍스는 이 두 단어를 줄여 말한단어입니다.
        - 상호 배제란 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구하는 것인데요, 쉽게 말해 하나의 프로세스가 공유 자원을 사용할 때 다른 프로세스가 동일한 공유자원에 접근할 수 없도록 통제하는 것을 말합니다.
        
        - 뮤텍스는 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 매커니즘입니다.
        - 뭔소리냐
        - 임계영역 음식점이라는 식당이 있습니다.
        - 지나가는 스레드1이라는 손님이 식당으로 들어갑니다.
        - 이 식당은 크기가 작아서 한명의 손님만 받을 수 있습니다.
        - 그리고 손님이 있는 동안에는 가게문을 걸어잠그고 그 손님에게만 집중합니다.
        - 여기서 손님이 임계영역 음식점에 들어가고 가게문을 걸어 잠그는 방식을 Lock방식이라고 합니다.
        - 음식점에 들어간 손님은 테이블을 점유하고 식사를 즐깁니다.
        - 그런데 다른 스레드2라는 손님이 이 식당을 발견합니다.
        - 스레드2는 배고파서 식사를 하기위해 식당에 진입하는데, 이미 식사중인 스레드1이 있기 때문에 식당에 들어가지 못하고 대기를해야합니다.
        - 여기서 스레드2가 대기하는 방식에 2가지가 있습니다.
        - 그럼이제 대기실이 있고, 손님이 계속 옵니다.
        - 방법 하나는 손님이 들어온 순서대로 식사가 끝날때마다 식당에 들어가는 대기큐를 생성해두고 임계영역에 들어가게하는 방식이 있습니다.
        - 다른 방법으로는 계속 식당앞에서 물어보는 SpinLock 방식(대기실없음)입니다.
        - 대기하는 손님이 계속 물어본다면, 이런걸 Busy-Waiting이라고 하는데 이러면 식당 직원이 일을 못하니까 비효율적입니다.
        - 이런 경우는 효율적인 경우가 있는데, 컨텍스트 스위칭 시간이 짧을 경우, 그리고 그 계속 물어보는 사람을 상대할 코어가 있을때, 즉 멀티코어프로세스인 경우 좋습니다.

        - 세마포어는 멀티프로그래밍 환경에서 다수의 프로세스나 스레드가 n개의 공유 자원에 대한 접근을 제한하는 방법으로 사용되는 동기화 기법입니다.
        - 뮤텍스랑은 다르게 여러 스레드가 동시에 식당에 접근할 수 있다는 차이가 있는데요,
        - 음식점이 이번에는 테이블이 늘어났습니다. 한명이 아니라 세명을 상대할 수 있습니다.
        - 이제 수용가능한 손님수만큼 남은 좌석을 표시하고 모든 좌석이 점유되면 남은 좌석은 0으로 표시됩니다.
        

## 기술 추가 질문할것같은? 예상 질문
- OSI 7계층 전부 준비하기
- 특히 5~7계층 준비안돼있음
- 세션
- CSR, SSR [정리할 사이트](https://www.youtube.com/watch?v=YuqB8D6eCKE&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=22)
- FE 성능측정 [정리할 사이트](https://www.youtube.com/watch?v=A6J74xLWqYg&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=37)
- OS 교착상태 [정리할 사이트](https://www.youtube.com/watch?v=FXzBRD3CPlQ&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=96)
- 블로킹 논블로킹
- 이뮤터블
- 멀티 프로세스, 멀티스레드

## 인성 관련 예상

- 입사하시게 되면 내부 정보들을 많이 아시게 될텐데 어떤 스탠스를 가지고 해당 직무에 임하실건지?
    - 아마 제 지인들 중에 메이플스토리를 플레이하는 유저가 많아서 제가 개발진이 된다는 소식을 알게될 것 같습니다.
    - 메이플스토리 유저의 입장에서 내부에서 어떤 얘기가 오가는지, 무슨 업데이트가 후에 진행될 예정인지 많이 궁금해할것같기도 한데 이런 내용에 대한 질문을 저에게 많이 할것같습니다.
    - 개발진으로 일하게 되는 만큼 제 업에 책임감을 가지고 직무에 임하겠습니다.
    - 사실 개발진의 한마디 한마디가 커뮤니티같은 곳에 퍼지게 된다면 그로인한 인게임 재화의 시세 변동이나, 게임에 대한 여론에서의 악영향이 있을수 있을것이라 예상합니다.
    - 그런 일이 발생하지 않도록 사소한 제 한마디 한마디에도 신경쓰며 생활할 것이고, 저로 인해 절대로 큰 문제가 발생하지 않도록 하겠습니다.

- 원래 프론트를 좋아하시고 백엔드에서 재미를 찾으면 공부 잘할수있다고 하셨는데 구체적으로 설명좀요
    - 1차면접을 보고 최종면접을 준비하면서 1차면접때 제대로 답변을 못드렸던 질문들을 다시 정리해봤습니다.
    - 그중에 클러스터드 인덱스를 공부하면서 좀 재밌었다고 느꼈습니다.
    - 인덱스를 사용하는 근본적인 이유가 데이터 조회를 빠르게 하는데에 있습니다.
    - 사실 제가 알고리즘 문제를 즐겨 푸는 이유에도 문제를 푸는 방법에 여러가지가 있을 수 있는데, 어떤 알고리즘을 사용하면 시간초과가 나고, 또 어떤 알고리즘을 사용하면 남들보다 빠른 시간복잡도로 문제를 해결할 수가 있는데 이런 부분에서 재미를 느끼거든요.
    - 인덱스에서도 어떠한 경우에는 사용하느니만 못한 경우가 있고, 어떤 경우에는 잘 사용하면 조회 속도가 눈에띄게 빨라지는 경우가 있더라구요.
    - 그래서 실무에서도 제가 맡게될 일이 백엔드 분야라고 말씀해주셨던것같은데 프론트가 아니더라도 이런부분에서 재미를 느끼고 개발에 있어 기여를 할 수 있다고 생각합니다.

- 왜 개발자가 되기로 결심했나요
    - 어릴때부터 컴퓨터를 좋아했습니다.
    - 어릴때는 단순히 게임을 좋아했던거였지만, 사실 중간에 좋지않은 방법을 통해서 개발에 관심이 생겼습니다.
    - 중학교 때 게임에서 어떤 이벤트 아이템을 얻기 위해서 매크로를 만들었었습니다.
    - 매크로 프로그램을 만든거는 아니고, IO작업을 도와주는 프로그램을 통해서 몇초후에 키보드입력, 마우스클릭같은 것들을 일련의 과정을 통해 제가 원하는 방식으로 작동하게 하는 매크로였고 그때는 그게 참 신기했습니다. 물론 지금은 그런방식에 대해서 절대 좋은생각을 가지고있지는 않습니다.
    - 그러면서 개발이라는 것에 대해 관심이 생겼고, 개발 공부를 해오면서는 이제 컴퓨터라는게 생활에서는 없어서는 안되는 것이 되어버리고, 사람들에게 때로는 재미를주기도 하고 생활을 편하게도 만들어주기도 합니다.
    - 최근에는 메이플스토리 BGM Quiz라는 프로젝트를 하면서 사람들에게 재미를 주는 컨텐츠도 만들고 사람들이 재미있어하는 것을 보니 확실하게 개발자가 되어야겠다고 생각했습니다.

- 3/5/10년 후의 나를 상상해본다면?
    - 연차가 쌓이고, 주니어에서 이제 시니어가 된다면 더 메이플스토리 운영에 대해서 많이 알게될거라 생각합니다.
    - 제가 쌓은 노하우와 경험들을 바탕으로 제 다음에 들어온 후배들에게도 전수해 주며 끌어주는 선배가 되고 싶습니다.
    - 또한 제가 쌓은 궤적이 후배들이 따라가고픈 영역이 될 수 있도록 바람직한 길을 가기 위해 최선을 다할 것입니다.

- 어떤 개발자가 잘하는 개발자라고 생각하나요?
    - 우선 개발자에게 필요한 역량중 하나는 다른 개발자와 의사소통을 원활하게 할 수 있는 능력이라고 생각합니다.
    - 입사하게 된다면 작은 프로젝트에 대한 개발을 하는 것이 아니라 실제로 서비스되는, 큰 규모의 시스템에 대한 개발을 진행하게 될텐데 만약 어떤 이슈가 발생한다고 해보겠습니다.
    - 그 이슈에 대한 해결방법을 찾아나가는 과정에서, 물론 여기서 해결방법을 잘 찾아나가는 능력도 중요하겠지만 분명히 완전한 해결방법을 떠올릴 수 없는 이슈도 존재한다고 생각합니다.
    - 그런 상황에는 다른 개발자분들과 머리를 맞대서 최적의 해결방법을 찾아나가야 할텐데 이런부분에서 서로 말이 잘통해야 할 것이고, 그 이슈로부터 추가적으로 발생할 수 있는 또다른 이슈가 없는 방향으로 의사소통하는 것이 중요하다고 생각합니다.
    
- 장점/단점
    - 제가 생각하는 저의 장점은 조금 진부할수도 있는데 끈기라고 말씀드리고 싶습니다.
    - 저는 제가 어떤 분야에 관심이 생기고, 충분한 시간이 있다면 그에 대한 전문적인 사람이 되고싶어하는 성격입니다.
    - 이거를 증명해드리기 위해서는 근거가 있어야할텐데, 우선 게임...이긴 하지만 메이플스토리 유니온 8400이상으로 제 계정을 육성중이구요.
    - 취미로 하고있는 피아노는 어릴때 콩쿨에 나가서 상도 탈 만큼 재미들여 치기도 했고 현재도 비전공자 수준에서는 꽤 괜찮은 연주실력을 가지고 있다고 생각합니다.
    - 최근에는 깃허브, 백준 잔디에 관심이 생겨서 수개월간 하루에 적어도 한번은 꼭 코드를 작성하여 문제를 풀거나, 개발을 하는 끈기를 여기에 적용시키고 있습니다.

    - 단점으로는 이제 이 끈기를 적용하다보면 해야하는 여러가지 일이 생겼을때 관심분야에 먼저 투자하다보니 나머지 일을 못하게 되는 경우가 있다는 것입니다.
    - 부스트캠프에서 프로젝트를 하던 도중의 일인데 한 이슈를 발견하고 그 주의 목표를 이루기 위해서는 킵해놓고 다음 작업을 해야하는 경우였습니다.
    - 그 이슈에 대해서 해결할수 있을것같은데? 라는 생각을 계속 가지면서 시간을 투자했지만, 결국 시간을 너무 많이 들인 탓에 다음 작업을 하지 못하고 주말에 추가작업을 했던 경험이 생각납니다.
    - 이후로는 팀원에게 우선순위를 정해놓고 처리하면 좋겠다는 피드백을 받고 이제 이 단점을 고치려고 많이 노력했구요. 
    - 추가로 목표를 너무 크게 잡은것같을때는 재설정해서 달성할 수 있는 목표로도 전환하는 습관을 가지려는 시도를 하려고 하고 있습니다.

- 살면서 힘들었던 시기와 극복해낸 방법
    - 20년도에 영어 공부를 위해 6개월 예정의 어학연수를 떠났다가 코로나때문에 3주만에 돌아오게 되었습니다.
    - 휴학을 결심하고 떠난 어학연수인만큼 그 과정이 무너지게되어 자가격리하는 동안 좌절감이 들었습니다.
    - 한 이틀정도 너무 아쉬운 마음에 힘들어하고 있다가, 이왕 이렇게된거 어차피 내가 힘든거 아무도 알아주지 않는다, 결국 앞일은 내가 만들어야한다, 생산적인 일 할게 없을까 생각하다가 알고리즘 공부를 본격적으로 시작하게 되었습니다.
    - 이전에 대학에서 알고리즘 수업을 재미있게 들었었고, 개발자로 살아가려면 어차피 코딩테스트도 준비해야 했기때문에 공부를 시작하게 됐습니다.
    - 문제를 하나하나 풀어나가면서 제 코드에대한 시간복잡도를 보는게 재미있었고, 그 공부를 하던 와중에 영어 공부도 하면 좋겠다는 생각에 알고리즘 문제를 영어로 푸는 사이트를 찾았습니다.
    - 저는 Codeforces라는 사이트를 발견했고, 이 사이트는 경쟁형 프로그래밍 대회가 주기적으로 열리는 사이트였습니다.
    - 모든 텍스트가 영어였고, 하다보면 자연스럽게 영어공부도 될것같은 생각에 적극적으로 임했습니다.
    - 알고리즘 문제를 푸는 실력도 올리면서, 영어공부도 겸사겸사 할수있어서 대회가 열릴때마다 참가하는데 재미를 붙이게 되었습니다.
    - 대략 8개월동안 60번의 대회에 참가하며 개인적으로 목표했던 Specialist 레이팅에 달성하였으며 하마터면 좌절될뻔했던 시간이 헛되지 않았다는 마음에 뿌듯했던 경험이 있습니다.

- (지원동기) 우리 회사에 왜 지원했나? / 오면 무슨 일을 할수있는지?
    - 우선 저는 개발자의 꿈을 가지고 공부해오면서도, 메이플스토리를 꾸준히 오랜시간 플레이해오던 유저였습니다.
    - 때문에 쇼케이스나 라이브토크같은 것들을 챙겨보곤 했는데요,
    - 이제그런 컨텐츠가 끝나기 직전에 디렉터님께서 그런 말씀을 해주시더라구요.
    - 개발자를 많이 채용하고 있으니 적극적인 지원바랍니다 이런 말씀을 해주셨어요.
    - 그거를 듣고 이제 개발자를 지망하던 학생으로서 "아 내가 메이플스토리도 재밌어하고 개발도 재밌어하는데 이 두개를 동시에 할수있으면 참 좋겠다"는 생각을 하게 되었습니다. 물론 업무시간에 일안하고 게임을하겠다는 의미는 아니고 즐거움을 느끼는 두개가 일치되면 좋겠다는 의미입니다.
    - 사실 그 말씀을 처음 방송에서 하셨던건 메이플 어스 블로그가 나오기 전으로 기억합니다.
    - 그때부터 아마 상시채용 공고를 주기적으로 확인을 했던것 같아요.
    - 그때는 사실 준비가 덜 되었다고 생각해서 공부를 더 하고 지원을 해보고싶은 마음이었구요.
    - 지금은 나름대로 공부를 해온 상태이고, 사실 공고가 뭔가 더 미루면 마감될것같은마음에 지원하게 되었습니다.(웃으며)
    - 네 뭐 결론은 제가 즐거움을 느끼는 두개가 일치된다면 개발자로서 회사에 기여하고, 개인적으로 성장하는데에도 도움이 될것같은 마음에 지원하게 되었습니다.

    - 오목, 메이플 MBTI(신규유입에 있어 도움이 될) 얘기

- 무슨 일을 하게 될것같은지?
    - 메이플 라이브 서비스실에서 일하게 될 것으로 알고있습니다.
    - MapleUs 블로그에서 작성된 글을 보긴 했습니다만 내부 운영툴을 개발하는데, 인게임에서 발생할 수 있는 비정상적인 재화 획득에 대한 모니터링과 그 로그들을 분석해서 UI로 보여주는 일을 한다고 이해했습니다.

- 갈등 관리
    - 제 성격 자체가 약간 감정에 몰입돼서 이성적인 판단을 못하는 그런 성격은 아닙니다.
    - 웬만하면 모든 상황에서 침착함을 유지하는것 같다고 개인적으로 생각하구요
    - 그래서인지 제가 팀원과 갈등이 있었던 적은 솔직히 없고 중간에서 중재했던 경험은 있습니다.
    - ~~

- 스트레스 관리는 어떻게 하시나요?
    - 저는 취미를 통해서 해소하는 편입니다.
    - 웬만하면 스스로 하루에 해야하는 루틴을 정해놓는 편이기도 하고 항상성을 유지하는 것이 중요하다고 생각합니다.
    - 그래서 일에 지장이 생길만큼 스트레스가 쌓이는 주기가 길다고 생각합니다.
    - 그래도 그런일이 생기면 높은곳에 가서 맥주를 마시거나, 피아노를 치면서 스트레스를 풉니다.
    - 특히 메이플스토리 BGM을 피아노로 연주하는것을 즐깁니다.

- 면접 끝나기 전에 궁금한거 질문 있나요?
    - 제가 개발중인 MapleBGMQuiz 레포를 보셨을지 모르겠는데 현재 메이플스토리 인게임 BGM을 사용하는 부분에서 배포하면 저작권의 문제가 발생할지 궁금합니다. 개발 공부용이기 때문에 수익을 내거나하는 건 아니고 BGM을 이용한 2차 창작물을 배포해도 괜찮은지 궁금합니다. 관련해서 문의를 넣어놓은 상태인데 답변이 안와서 여쭤봅니다.
    
    - 면접 결과가 좋지않다면 재지원해도 될까요?
        - -> 면접 떨어질것같으신가요?
            - 그래도 꼭 가고싶은 회사여서 결과가 좋지않다면 재지원하게 될것같습니다
        - -> ㅇㅎ..네 재지원 가능합니다
        - -> 그럼 재지원 주기는 얼마정도 텀을두고 하는게 좋을지 궁금합니다
